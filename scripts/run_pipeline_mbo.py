from pathlib import Path
import time
import logging

import numpy as np
from numpy.typing import ArrayLike

import torch
import tifffile
from matplotlib.patches import Rectangle

import masknmf

logger = logging.getLogger(__name__)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

if not torch.cuda.is_available():
    print(
        "CUDA is not available. Using CPU instead.\n"
        "If you have a GPU, check your CUDA installation with:\n"
        "  nvcc --version\n"
        "and note the 11x or 12x version (e.g. Build cuda_12.6.r12.6/compiler.34841621_0).\n"
        "To install the correct version of PyTorch with CUDA, go to:\n"
        "  https://pytorch.org/get-started/locally/\n"
        "and select your system configuration to get the appropriate pip or conda command."
    )
    DEVICE = "cpu"
else:
    DEVICE = "cuda"
    print(f"Using CUDA with device: {torch.cuda.get_device_name(0)}")


def norm_minmax(imgs: np.ndarray) -> np.ndarray:
    """
    Normalize a NumPy array to the [0, 1] range.

    Parameters
    ----------
    imgs: np.ndarray) -> np.ndarray: : numpy.ndarray
       The input array to be normalized.

    Returns
    -------
    numpy.ndarray
       The normalized array with values scaled between 0 and 1.

    Examples
    --------
    >>> import numpy as np
    >>> arr = np.array([10, 20, 30])
    >>> norm_minmax(arr)
    array([0. , 0.5, 1. ])
    """
    return (imgs - imgs.min()) / (imgs.max() - imgs.min())

def plot_pmd_projection(
        results_dir: str | Path,
        savepath=None,
        fig_label=None,
        add_scalebar=False,
        dx=2.0
):
    """
    Plot PMD projection with ROIs overlaid similarly to Suite2p plot_projection.

    Parameters
    ----------
    results_dir : str or Path
        Directory where the results are saved.
    savepath : Path or None
        Where to save the image (optional).
    fig_label : str or None
        Optional label for the figure.
    add_scalebar : bool
        Add a scale bar to the plot.
    dx : float
        Microns per pixel.
    """
    import matplotlib.pyplot as plt

    res = load_from_dir(results_dir)

    a = res["a"]
    demixer = res["pmd_demixer"]

    proj = demixer.pmd_obj.mean_img.to("cpu")
    shape = proj.shape

    fig, ax = plt.subplots(figsize=(6, 6), facecolor='black')

    vmin = np.nanpercentile(proj, 2)
    vmax = np.nanpercentile(proj, 98)
    if vmax - vmin < 1e-6:
        vmax = vmin + 1e-6

    ax.imshow(proj, cmap='gray', vmin=vmin, vmax=vmax)
    masks = np.nanmax(a, axis=-1)
    overlay = np.zeros((*shape, 4), dtype=np.float32)
    overlay[..., 1] = 1
    overlay[..., 3] = (masks > 0) * 1.0
    ax.imshow(overlay)

    ax.set_xticks([])
    ax.set_yticks([])
    if fig_label:
        fig_label = fig_label.replace("_", " ").replace("-", " ").replace(".", " ")
        ax.set_ylabel(fig_label, color='white', fontweight='bold', fontsize=12)

    if add_scalebar:
        scale_bar_length = 100 / dx
        scalebar_x = shape[1] * 0.05
        scalebar_y = shape[0] * 0.90
        ax.add_patch(Rectangle((scalebar_x, scalebar_y), scale_bar_length, 5,
                               edgecolor='white', facecolor='white'))
        ax.text(scalebar_x + scale_bar_length / 2, scalebar_y - 10,
                "100 Î¼m", color='white', fontsize=10, ha='center', fontweight='bold')

    for spine in ax.spines.values():
        spine.set_visible(False)

    plt.tight_layout()
    if savepath:
        savepath.parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(savepath, dpi=300, facecolor='black')
        plt.close(fig)
    else:
        plt.show()


def load_from_dir(plane_dir):
    """
    Load all result files generated by `run_plane` from a given plane directory.

    Returns
    -------
    dict
        Dictionary with the following keys:

        - 'moco': np.ndarray
              Motion-corrected data array.

        - 'pmd_demixer': object
              Deserialized PMD demixer object containing the full demixing state.

        - 'a': np.ndarray
              Spatial components array with shape (height, width, n_components).
              Each component is a 2D spatial footprint.

        - 'c': np.ndarray
              Temporal components array with shape (n_frames, n_components).
              Each column is a time series for one component.
    """
    plane_dir = Path(plane_dir).expanduser()

    results = {}
    moco_path = plane_dir / "data_reg.npy"
    pmd_demixer_path = plane_dir / "pmd_demixer.npy"
    a_path = plane_dir / "a.npy"
    c_path = plane_dir / "a.npy"

    if moco_path.exists():
        results["moco"] = np.load(moco_path, allow_pickle=True)
    if pmd_demixer_path.exists():
        results["pmd_demixer"] = np.load(pmd_demixer_path, allow_pickle=True).item()
    if a_path.exists():
        results["a"] = np.load(a_path)
    if c_path.exists():
        results["c"] = np.load(c_path)
    return results


def run_plane(
        data_array: ArrayLike,
        zplane: int | str | Path,
        save_path=None,
        ops=None,
        debug=False,
        overwrite=False,
):
    if ops is None:
        ops = {}

    debug = debug
    if debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    save_path = Path.home() / ".masknmf" if save_path is None else Path(save_path).expanduser()

    save_path.mkdir(exist_ok=True)
    if isinstance(zplane, int):
        plane_dir = save_path / f"plane{zplane}"
    else:
        plane_dir = save_path / zplane
    plane_dir.mkdir(exist_ok=True)

    do_rigid = ops.get("do_rigid", True)
    do_nonrigid = ops.get("do_nonrigid", False)

    # motion correction
    reg_data_file = plane_dir / "data_reg.npy"
    if reg_data_file.exists():
        logger.info("Found moco results.")
        if overwrite:
            logger.info("Overwriting existing moco results.")
            return
        else:
            # Load existing motion-corrected data
            logger.info("Loading moco")
            dense_moco = np.load(reg_data_file)
    else:
        _, H, W = data_array.shape
        block_size = 100
        num_blocks = (
            max(1, W // block_size),
            max(1, H // block_size),
        )
        logger.info(
            f"Running registration: rigid = {do_rigid},"
            f" nonrigid = {do_nonrigid},"
            f" num_blocks = {num_blocks}"
        )
        rigid_strategy = masknmf.RigidMotionCorrection(max_shifts=(5, 5))
        pwrigid_strategy = masknmf.PiecewiseRigidMotionCorrection(
            num_blocks=num_blocks,
            overlaps=(5, 5),
            max_rigid_shifts=(5, 5),
            max_deviation_rigid=(2, 2),
        ) if do_nonrigid else None
        num_pw_iters = 1 if do_nonrigid else 0

        mc_strategy = masknmf.motion_correction.compute_template(
            data_array,
            rigid_strategy,
            num_iterations_piecewise_rigid=num_pw_iters,
            pwrigid_strategy=pwrigid_strategy,
            device=DEVICE,
            batch_size=1000,
        )

        moco_array = masknmf.RegistrationArray(
            data_array,
            strategy=mc_strategy if (do_rigid or do_nonrigid) else rigid_strategy,
            device=DEVICE,
        )
        dense_moco = moco_array[:]
        np.save(plane_dir / "data_reg.npy", dense_moco)

    # PMD decomposition
    t_pmd = time.time()
    pmd_obj = masknmf.compression.pmd_decomposition(
        dense_moco, (32, 32), dense_moco.shape[0],
        max_components=10, background_rank=10, device=DEVICE,
    )
    print(f"PMD took {time.time() - t_pmd:.2f}s")

    del dense_moco
    pmd_demixer = masknmf.demixing.signal_demixer.SignalDemixer(pmd_obj, device=DEVICE, frame_batch_size=100)
    np.save(plane_dir / "pmd_demixer.npy", pmd_demixer, allow_pickle=True)
    logger.info(pmd_demixer.state.state_description)

    init_kwargs = {
        'mad_correlation_threshold': 0.85,
        'min_superpixel_size': 5,
        'robust_corr_term': 1,
        'mad_threshold': 1,
        'residual_threshold': 0.3,
        'patch_size': (40, 40),
        'plot_en': True,
        'text': False,
    }

    # Initialize signals
    try:
        pmd_demixer.initialize_signals(**init_kwargs, is_custom=False)
    except ValueError as e:
        print(f"Initialization for input {zplane} failed: {e}")
        text = "Initialization failed, skipping plane."
        np.save(plane_dir / "error.npy", text)
        return
    logger.info(f"Identified {pmd_demixer.results[0].shape[1]} neurons here")
    np.save(plane_dir / "pmd_demixer.npy", pmd_demixer, allow_pickle=True)

    pmd_demixer.lock_results_and_continue()
    logger.info(pmd_demixer.state.state_description)

    num_iters = 25
    localnmf_params = {
        'maxiter': num_iters,
        'support_threshold': np.linspace(0.95, 0.8, num_iters).tolist(),
        'deletion_threshold': 0.2,
        'ring_model_start_pt': 4,
        'ring_radius': 10,
        'merge_threshold': 0.8,
        'merge_overlap_threshold': 0.8,
        'update_frequency': 4,
        'c_nonneg': True,
        'denoise': False,
        'plot_en': True
    }

    # Demix 1
    start_time = time.time()
    with torch.no_grad():
        pmd_demixer.demix(**localnmf_params)
    print(f"that took {time.time() - start_time}")
    print(f"after this step {pmd_demixer.results.a.shape[1]} signals identified")

    pmd_demixer.lock_results_and_continue(carry_background=True)

    init_kwargs = {
        'mad_correlation_threshold': 0.9,
        'min_superpixel_size': 5,
        'robust_corr_term': 1,
        'mad_threshold': 0,
        'residual_threshold': 0.3,
        'patch_size': (40, 40),
        'plot_en': True,
        'text': False,
    }

    try:
        pmd_demixer.initialize_signals(**init_kwargs, is_custom=False)
    except ValueError as e:
        print(f"Initialization for input {zplane} failed: {e}")
        text = "Initialization failed, skipping plane."
        np.save(plane_dir / "error.npy", text)
        return

    print(f"Identified {pmd_demixer.results[0].shape[1]} neurons here")
    pmd_demixer.lock_results_and_continue(carry_background=True)

    # Demix 2
    with torch.no_grad():
        pmd_demixer.demix(**localnmf_params)
    print(f"that took {time.time() - start_time}")
    print(f"after this step {pmd_demixer.results.a.shape[1]} signals identified")
    np.save(plane_dir / "pmd_demixer.npy", pmd_demixer, allow_pickle=True)

    a = pmd_demixer.results.ac_array.export_a()
    c = pmd_demixer.results.ac_array.export_c()
    np.save(plane_dir / "a.npy", a)
    np.save(plane_dir / "c.npy", c)
    logger.info((a.shape, c.shape))
    print(f"complete, saved to {plane_dir}")
    plot_pmd_projection(plane_dir, savepath=plane_dir / "projection.png")


if __name__ == "__main__":

    inpath = r"D:\tests_bigmem\roi2"
    savedir = r"D:\tests_bigmem\roi2\masknmf"

    completed = [x.stem for x in Path(savedir).iterdir()]

    Path(savedir).mkdir(exist_ok=True)
    files = sorted(list(Path(inpath).glob("*.tif*")))
    ops = {
        "do_rigid": True,
        "do_nonrigid": True,
    }

    for file in files:
        if file.stem in completed:
            print(f"Skipping {file.stem}, already processed.")
            continue
        data_arr = tifffile.memmap(file)
        run_plane(
            data_array=data_arr,
            zplane=file.stem,
            save_path=savedir,
            ops=ops,
            debug=False,
            overwrite=True
        )
